1.	Вариант использования паттерна Стратегия №1. Я использовал паттерн стратегия для передвижения космического корабля между станциями. У корабля есть точка куда ему нужно долететь. Другой класс, который следил за полетами, назовем его ЦУП, смотрел какое расстояние от корабля до точки, если больше 100 юнитов, то передавал кораблю, класс, который отвечал за путешествие на маршевом двигателе, если больше 100, но меньше 50, то передавал ему уже класс, который разворачивал корабль и тормозил этим же маршевым двигателем и по достижении 10 юнитов передавал класс, который уже перемещал корабль посредством маневровых двигателей, чтобы шлюз корабля соединить со шлюзом станции. 
2.	Вариант использования паттерна Стратегия №2. Ничего особенного мне в голову не приходит, все будет примерно одинаково по смыслу. Ну к примеру, у нас может быть класс экономики страны, города, не важно. Есть класс Observer, у него есть 4 класса методики расчета. Каждый месяц ему приходит уведомление, что прошел месяц и пора посчитать статистику. Observer смотрит какой сезон и ставит классу Экономики класс методики расчета в зависимости от сезона.
3.	Вариант использования паттерна Шаблонный метод №1. Пример из своего проекта. С помощью шаблонного метода я наполняю список ScrollView на экране. У меня есть абстрактный класс ListInView у которого есть список List<Item> items. Item это тоже абстрактный класс, монобех у которого есть ссылка на свой TextMesh, свойства имя и id который мы присваиваем ему. Так вот, в класс ListInView поступает список List<INameAndId> names, где интерфейс INameAndId содержит два свойства Name и Id. Создает на базе этого списка через Instance список items в которые сразу закладываются имя и id. А потом запускается абстрактный метод дальнейшей работы WorkWithList(List<INameAndId> names). И вот тут различия. Списки могут быть разные, в каком-то списке по нажатию этот объект должен выделяться/выбираться, в каком-то удаляться, а в каком-то все вместе, а в каком-то список — это просто список, в добавок сам переданный список может содержать как оружие, так и товары или персонажей. И за это отвечает уже класс, наследник, который добавляет функционал и делает Downcaster Item к его наследнику, который мы изначально добавили в поле ListInView, и downcaster INameAndId к классу, который мы подразумеваем. Если это список оружия, то к классу Weapon и добавляем к названию еще его базовый урон к примеру. Ну и сами объекты Item могут иметь разную реализацию, у кого-то один делегат на возвращение id, у кого-то два, один означает удаление, другой выбор. 
Тут получается два примера шаблонного метода в одном.
